
  #创建型模式--原型模式
 
   模式简介
   
    在使用原型模式时，我们需要首先创建一个原型对象，再通过复制这个原型对象来创建更多同类型的对象
    工作原理很简单：将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝自己来实现创建过程。
    需要注意的是通过克隆方法所创建的对象是全新的对象，它们在内存中拥有新的地址，通常对克隆所产生的对象进行修改对
    原型对象不会造成任何影响，每一个克隆对象都是相互独立的
    
    需要注意两种不同的克隆方法，浅克隆（ShallowClone）和深克隆（DeepClone）
    
    浅克隆（ShallowClone）：
    
    如果原型对象的成员变量是值类型，将复制一份给克隆对象；如果原型对象的成员变量是引用类型，
    则将引用对象的地址复制一份给克隆对象，也就是说原型对象和克隆对象的成员变量指向相同的内存地址。
    简单来说，在浅克隆中，当对象被复制时只复制它本身和其中包含的值类型的成员变量，而引用类型的成员对象并没有复制
    
    通过覆盖Object类的clone()方法可以实现浅克隆
    
    深克隆（DeepClone）：
    
    无论原型对象的成员变量是值类型还是引用类型，都将复制一份给克隆对象，深克隆将原型对象的所有引用对象
    也复制一份给克隆对象。简单来说，在深克隆中，除了对象本身被复制外，对象所包含的所有成员变量也将复制。
    
    如果需要实现深克隆，可以通过序列化(Serialization)等方式来实现。序列化就是将对象写到流的过程，
    写到流中的对象是原有对象的一个拷贝，而原对象仍然存在于内存中。通过序列化实现的拷贝不仅可以复制对象本身，
    而且可以复制其引用的成员对象，因此通过序列化将对象写到一个流中，再从流里将其读出来，可以实现深克隆
    
   设计理念
   
    通过对原型对象的拷贝（clone），快速完成新对象的创建
    
   相关角色
   
    1、Prototype（抽象原型类） ：它是声明克隆方法的接口，是所有具体原型类的公共父类，
    可以是抽象类也可以是接口，甚至还可以是具体实现类。
    2、ConcretePrototype（具体原型类） ：它实现在抽象原型类中声明的克隆方法，在克隆方法中返回自己的一个克隆对象
    3、Client（客户类），让一个原型对象克隆自身从而创建一个新的对象，在客户类中只需要直接实例化
    或通过工厂方法等方式创建一个原型对象，再通过调用该对象的克隆方法即可得到多个相同的对象
    
   优劣分析
   
    优势：
        1、当创建新的对象实例较为复杂时，使用原型模式可以简化创建的过程，通过复制一个已有的实例提高新实例的创建效率
        2、扩展性较好，由于在原型模式中提供了抽象原型类，在客户端可以针对抽象原型类进行编程，
        而将具体原型类写在配置文件中，增加或减少产品类对原有系统都没有任何影响
        3、原型模式提供了简化的创建结构原型模式中产品的复制是通过封装在原型类中的克隆方法实现的，无须专门的工厂类来创建产品
        4、可以使用深克隆的方式保存对象的状态，可辅助实现撤销操作
        
    劣势：
        1、需要为每一个类配备一个克隆方法，而且该克隆方法位于一个类的内部，当对已有的类进行改造时，
        需要修改源代码，违背了“开闭原则”
        2、在实现深克隆时需要编写较为复杂的代码，而且当对象之间存在多重的嵌套引用时，为了实现深克隆，
        每一层对象对应的类都必须支持深克隆，实现起来可能会比较麻烦
    
   适用场景
    
    1、创建新对象成本较大
    2、如果系统要保存对象的状态，而对象的状态变化很小，或者对象本身占用内存较少时，
    可以使用原型模式配合备忘录模式来实现
    3、需要避免使用分层次的工厂类来创建分层次的对象，通过复制原型对象得到新实例可能比使用构造函数创建一个新实例更加方
   
   Demo介绍
   
    1、ShallowCustomer(浅克隆类) 包含一个ShallowAddress引用属性类型成员 
    2、DeepCustomer(深克隆类) 包含一个DeepAddress引用属性类型成员
    

   
   

   
